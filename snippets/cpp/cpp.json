{
  "ordered_set": {
    "prefix": "ordered_set",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T, typename ComparatorFn = less<T>>",
      "using ordered_set = tree<T, null_type, ComparatorFn, rb_tree_tag,",
      "                         tree_order_statistics_node_update>;"
    ],
    "description": "policy based ordered_set"
  },
  "cppt": {
    "prefix": "cppt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define all(x) begin(x), end(x)",
      "#define OUT(T) cout << \"Case #\" << T << \": \"",
      "",
      "#ifdef _DEBUG",
      "#include \"debugs.h\"",
      "#else",
      "#define dbg(...)",
      "#define endl '\\n'",
      "#endif",
      "",
      "// clang-format off",
      "template<typename T, typename V> bool ckmax(T &a, V b) { return (long long) a < (long long) b ? a = b, 1: 0; }",
      "template<typename T, typename V> bool ckmin(T &a, V b) { return (long long) a > (long long) b ? a = b, 1: 0; }",
      "template <typename T> ostream &operator<<(ostream &out, const vector<T> &v) { for (const auto &x : v) out << x << ' '; return out; }",
      "template <typename T> istream &operator>>(istream &in, vector<T> &v) { for (auto &x : v) in >> x; return in; }",
      "// clang-format on",
      "",
      "using ll = long long;",
      "using lld = long double;",
      "using pll = pair<ll, ll>;",
      "using pii = pair<int, int>;",
      "",
      "void solve(ll _t) {}",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false), cin.tie(NULL);",
      "",
      "  ll T = 1;",
      "  cin >> T;",
      "  for (ll t = 1; t <= T; ++t)",
      "    solve(t);",
      "}"
    ],
    "description": "weird snippet"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "struct sieve_t {",
      "  sieve_t(int n, bool gen_primes = false, bool gen_sieve = false) {",
      "    is_prime.assign(n + 1, true);",
      "    is_prime[0] = is_prime[1] = false;",
      "    for (int i = 2; i * i <= n; ++i) {",
      "      for (int j = i * i; j <= n; j += i) is_prime[j] = false;",
      "    }",
      "    if (gen_primes) {",
      "      for (int i = 2; i <= n; ++i) {",
      "        if (is_prime[i]) primes.push_back(i);",
      "      }",
      "    }",
      "    if (gen_sieve) {",
      "      sieve.assign(n + 1, -1);",
      "      for (int i = 2; i <= n; ++i) {",
      "        if (is_prime[i]) {",
      "          sieve[i] = i;",
      "          if ((ll)i * i <= n) {",
      "            for (int j = i * i; j <= n; j += i) {",
      "              if (sieve[j] == -1) sieve[j] = i;",
      "            }",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "  // requires gen_fact; works only upto sz;",
      "  vector<int> fast_factorize(int k) {",
      "    vector<int> res;",
      "    while (k > 1) {",
      "      ll p = sieve[k];",
      "      res.push_back(p);",
      "      k /= p;",
      "    }",
      "    return res;",
      "  }",
      "  // requies gen_primes; works upto sz*sz;",
      "  vector<int> factorize(int k) {",
      "    vector<int> res;",
      "    for (int p : primes) {",
      "      if (p * p > k) break;",
      "      while (k % p == 0) {",
      "        k /= p;",
      "        res.push_back(p);",
      "      }",
      "    }",
      "    if (k > 1) res.push_back(k);",
      "    return res;",
      "  }",
      "  vector<bool> is_prime;",
      "  vector<int> primes;",
      "  vector<int> sieve;",
      "};"
    ],
    "description": "my sieve template"
  },
  "modulo": {
    "prefix": "modulo",
    "body": [
      "template <int MOD>",
      "struct mint {",
      "  static const int mod = MOD;",
      "  int v;",
      "  explicit operator int() const { return v; }",
      "  mint() : v(0) {}",
      "  mint(ll _v) {",
      "    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
      "    if (v < 0) v += MOD;",
      "  }",
      "  bool operator==(const mint &o) const { return v == o.v; }",
      "  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }",
      "  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }",
      "  friend istream &operator>>(istream &is, mint &a) {",
      "    ll x;",
      "    is >> x;",
      "    a = mint(x);",
      "    return is;",
      "  }",
      "  friend ostream &operator<<(ostream &os, mint a) {",
      "    os << int(a);",
      "    return os;",
      "  }",
      "  mint &operator+=(const mint &o) {",
      "    if ((v += o.v) >= MOD) v -= MOD;",
      "    return *this;",
      "  }",
      "  mint &operator-=(const mint &o) {",
      "    if ((v -= o.v) < 0) v += MOD;",
      "    return *this;",
      "  }",
      "  mint &operator*=(const mint &o) {",
      "    v = int((ll)v * o.v % MOD);",
      "    return *this;",
      "  }",
      "  mint &operator/=(const mint &o) { return (*this) *= inv(o); }",
      "  friend mint pow(mint a, ll p) {",
      "    mint ans = 1;",
      "    assert(p >= 0);",
      "    for (; p; p /= 2, a *= a)",
      "      if (p & 1) ans *= a;",
      "    return ans;",
      "  }",
      "  friend mint inv(const mint &a) {",
      "    assert(a.v != 0);",
      "    return pow(a, MOD - 2);",
      "  }",
      "  mint to_pow(ll p) const { return pow(*this, p); }",
      "  mint to_inv() const { return inv(*this); }",
      "  mint operator-() const { return mint(-v); }",
      "  mint &operator++() { return *this += 1; }",
      "  mint &operator--() { return *this -= 1; }",
      "  friend mint operator+(mint a, const mint &b) { return a += b; }",
      "  friend mint operator-(mint a, const mint &b) { return a -= b; }",
      "  friend mint operator*(mint a, const mint &b) { return a *= b; }",
      "  friend mint operator/(mint a, const mint &b) { return a /= b; }",
      "};",
      "const ll MOD = 998244353;",
      "using mi = mint<MOD>;",
      "using vmi = vector<mi>;"
    ],
    "description": "modulo operations"
  },
  "combinatorics": {
    "prefix": "combinatorics",
    "body": [
      "struct {",
      "  vmi invs, fac, ifac;",
      "  void init(int N) {  // idempotent",
      "    invs.resize(N), fac.resize(N), ifac.resize(N);",
      "    invs[1] = fac[0] = ifac[0] = 1;",
      "    for (int i = 2; i < N; i++) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);",
      "    for (int i = 1; i < N; i++)",
      "      fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];",
      "  }",
      "  mi C(int a, int b) {",
      "    if (a < b || b < 0) return 0;",
      "    return fac[a] * ifac[b] * ifac[a - b];",
      "  }",
      "} F;"
    ]
  },
  "sparse": {
    "prefix": "sparse table",
    "body": [
      "struct min_op {",
      "  ll operator()(ll a, ll b) { return min(a, b); }",
      "};",
      "struct max_op {",
      "  ll operator()(ll a, ll b) { return max(a, b); }",
      "};",
      "struct gcd_op {",
      "  ll operator()(ll a, ll b) { return __gcd(a, b); }",
      "};",
      "template <typename OperationT>",
      "struct sparse_table {",
      "  vector<vector<ll>> m;",
      "  OperationT op;",
      "  template <typename Itr>",
      "  void init(Itr begin, Itr end) {",
      "    ll sz = end - begin;",
      "    ll lg = 63 - __builtin_clzll(sz);",
      "    m.assign(sz, vector<ll>(lg + 1));",
      "    for (ll j = 0; j <= lg; ++j) {",
      "      ll len = (1 << j);",
      "      for (ll i = 0; i + len - 1 < sz; ++i) {",
      "        if (len == 1) {",
      "          m[i][j] = *(begin + i);",
      "        } else {",
      "          m[i][j] = op(m[i][j - 1], m[i + (1 << (j - 1))][j - 1]);",
      "        }",
      "      }",
      "    }",
      "  }",
      "  ll query(ll L, ll R) {",
      "    ll j = 63 - __builtin_clzll((R - L + 1));",
      "    return op(m[L][j], m[R + 1 - (1 << j)][j]);",
      "  }",
      "};"
    ],
    "description": "sparse table"
  },
  "DSU": {
    "prefix": "DSU",
    "body": [
      "struct DSU {",
      "  vector<int> parent, siz;",
      "  void init(int n) {",
      "    parent.resize(n);",
      "    siz.resize(n);",
      "    for (int i = 0; i < n; i++) {",
      "      parent[i] = i;",
      "      siz[i] = 1;",
      "    }",
      "  }",
      "  int find(int x) {",
      "    if (x == parent[x]) return x;",
      "    return parent[x] = find(parent[x]);",
      "  }",
      "  void merge(int x, int y) {",
      "    x = find(x);",
      "    y = find(y);",
      "    if (x == y) return;",
      "    if (siz[x] < siz[y]) swap(x, y);",
      "    parent[y] = x;",
      "    siz[x] += siz[y];",
      "  }",
      "  int size(int x) { return siz[find(x)]; }",
      "  bool same(int x, int y) { return find(x) == find(y); }",
      "};"
    ],
    "description": "disjoint set union"
  },
  "SegTree": {
    "prefix": "segtree",
    "body": [
      "template <typename T, typename CombineT>",
      "struct SegmentTree {",
      "  vector<T> tree;",
      "  CombineT combine;",
      "  T defaultValue;",
      "  ll n;",
      "",
      "  void init(ll n, T val) {",
      "    tree.resize(4 * n);",
      "    this->n = n;",
      "    defaultValue = val;",
      "    build_tree(1, 0, n - 1);",
      "  }",
      "",
      "  template<typename Itr>",
      "  void init(Itr begin, Itr end) {",
      "    n = distance(begin, end);",
      "    tree.resize(4 * n);",
      "",
      "    build_tree(1, 0, n-1, begin);",
      "  }",
      "  ",
      "  void build_tree(ll id, ll tl, ll tr) {",
      "    if (tl == tr) {",
      "      tree[id] = defaultValue;",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    build_tree(id * 2, tl, tm);",
      "    build_tree(id * 2 + 1, tm + 1, tr);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  template<typename Itr>",
      "  void build_tree(ll id, ll tl, ll tr, Itr begin) {",
      "    if (tl == tr) {",
      "      tree[id] = *(begin + tl);",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    build_tree(id * 2, tl, tm, begin);",
      "    build_tree(id * 2 + 1, tm + 1, tr, begin);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  T query(ll id, ll tl, ll tr, ll ql, ll qr) {",
      "    if (ql > tr || tl > qr) return defaultValue;",
      "    if (ql <= tl && tr <= qr) return tree[id];",
      "    ll tm = (tl + tr) / 2;",
      "    return combine(query(id * 2, tl, tm, ql, qr),",
      "                   query(id * 2 + 1, tm + 1, tr, ql, qr));",
      "  }",
      "",
      "  T query(ll l, ll r) { return query(1, 0, n - 1, l, r); }",
      "",
      "  void update(ll id, ll tl, ll tr, ll p, T x) {",
      "    if (tl == tr) {",
      "      tree[id] = x;",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    if (p <= tm)",
      "      update(id * 2, tl, tm, p, x);",
      "    else",
      "      update(id * 2 + 1, tm + 1, tr, p, x);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  void update(ll p, T x) { update(1, 0, n - 1, p, x); }",
      "};"
    ],
    "description": "Point update segment tree"
  },
  "binary_lift": {
    "prefix": "binary_lifting",
    "body": [
      "struct binary_lift {",
      "  vector<vector<ll>> children;",
      "  vector<ll> depth;",
      "  const ll LOG = 18;",
      "  void init(vector<vector<ll>> &adj) {",
      "    ll n = adj.size();",
      "    depth.resize(n);",
      "    children.assign(n, vector<ll>(LOG + 1));",
      "    function<void(ll, ll, ll)> dfs = [&](ll u, ll p, ll d) {",
      "      depth[u] = d;",
      "      children[u][0] = p;",
      "      for (ll i = 1; i <= LOG; ++i) {",
      "        children[u][i] = children[children[u][i - 1]][i - 1];",
      "      }",
      "      for (ll v : adj[u]) {",
      "        if (v != p) dfs(v, u, d + 1);",
      "      }",
      "    };",
      "    dfs(0, 0, 0);",
      "  }",
      "  ll lift_node(ll n, ll d) {",
      "    for (ll i = LOG; i >= 0; --i) {",
      "      if (d & (1 << i)) n = children[n][i];",
      "    }",
      "    return n;",
      "  }",
      "  ll lca(ll u, ll v) {",
      "    if (depth[u] < depth[v]) swap(u, v);",
      "    u = lift_node(u, depth[u] - depth[v]);",
      "    if (u == v) return u;",
      "    for (ll i = LOG; i >= 0; --i) {",
      "      if (children[u][i] != children[v][i]) {",
      "        u = children[u][i];",
      "        v = children[v][i];",
      "      }",
      "    }",
      "    return children[u][0];",
      "  }",
      "  ll dist(ll u, ll v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
      "};"
    ],
    "description": "binary lifting"
  },
  "euler_tour": {
    "prefix": "euler_tour",
    "body": [
      "struct euler_tour {",
      "  vector<ll> in, out;",
      "  ll timer = 0;",
      "  void init(vector<vector<ll>> &adj) {",
      "    ll n = adj.size();",
      "    in.resize(n);",
      "    out.resize(n);",
      "    function<void(ll, ll)> dfs = [&](ll u, ll p) {",
      "      in[u] = timer++;",
      "      for (ll v : adj[u]) {",
      "        if (v != p) dfs(v, u);",
      "      }",
      "      out[u] = timer++;",
      "    };",
      "    dfs(0, 0);",
      "  }",
      "  bool is_ancestor(ll u, ll v) { return in[u] <= in[v] && out[u] >= out[v]; }",
      "};"
    ]
  },
  "lazy segment tree": {
    "prefix": "lazy segtree",
    "body": [
      "template <typename node_type, typename tag_type>",
      "struct lazy_segtree {",
      "  vector<node_type> tree;",
      "  vector<tag_type> lazy;",
      "  int n;",
      "  template <typename Iter>",
      "  void init(Iter first, Iter last, int nn = -1) {",
      "    n = nn;",
      "    if (n == -1) n = distance(first, last);",
      "    tree.resize(4 * n);",
      "    lazy.resize(4 * n);",
      "    build_tree(0, 0, n - 1, first);",
      "  }",
      "  node_type query(int ql, int qr) { return query(0, 0, n - 1, ql, qr); }",
      "  void update(int ql, int qr, tag_type const &val) {",
      "    update(0, 0, n - 1, ql, qr, val);",
      "  }",
      " private:",
      "  template <typename Iter>",
      "  void build_tree(int id, int tl, int tr, Iter first) {",
      "    if (tl == tr) {",
      "      tree[id].init(tl, tr, *(first + tl));",
      "      lazy[id].init(tl, tr);",
      "      return;",
      "    }",
      "    int tm = (tl + tr) / 2;",
      "    build_tree(2 * id + 1, tl, tm, first);",
      "    build_tree(2 * id + 2, tm + 1, tr, first);",
      "    tree[id] = node_type::merge(tree[2 * id + 1], tree[2 * id + 2]);",
      "    lazy[id].init(tl, tr);",
      "  }",
      "  void push(int id, int tl, int tr) {",
      "    if (tl != tr) {",
      "      int tm = (tl + tr) / 2;",
      "      tree[2 * id + 1].apply(tl, tm, lazy[id]);",
      "      lazy[2 * id + 1].merge(lazy[id]);",
      "      tree[2 * id + 2].apply(tm + 1, tr, lazy[id]);",
      "      lazy[2 * id + 2].merge(lazy[id]);",
      "    }",
      "    lazy[id].reset();",
      "  }",
      "  node_type query(int id, int tl, int tr, int ql, int qr) {",
      "    if (tl > qr || ql > tr) return node_type::phi();",
      "    if (ql <= tl && tr <= qr) return tree[id];",
      "    push(id, tl, tr);",
      "    int tm = (tl + tr) / 2;",
      "    return node_type::merge(query(2 * id + 1, tl, tm, ql, qr),",
      "                            query(2 * id + 2, tm + 1, tr, ql, qr));",
      "  }",
      "  void update(int id, int tl, int tr, int ql, int qr, tag_type const &val) {",
      "    if (tl > qr || ql > tr) return;",
      "    if (ql <= tl && tr <= qr) {",
      "      tree[id].apply(tl, tr, val);",
      "      lazy[id].merge(val);",
      "      return;",
      "    }",
      "    push(id, tl, tr);",
      "    int tm = (tl + tr) / 2;",
      "    update(2 * id + 1, tl, tm, ql, qr, val);",
      "    update(2 * id + 2, tm + 1, tr, ql, qr, val);",
      "    tree[id] = node_type::merge(tree[2 * id + 1], tree[2 * id + 2]);",
      "  }",
      "};",
      "struct tag {",
      "  ll inc;",
      "  void reset() { inc = 0; }",
      "  void merge(tag const &other) { inc += other.inc; }",
      "  void init(int tl, int tr) {}",
      "};",
      "struct node {",
      "  static node phi() { return {0LL}; }",
      "  static node merge(node const &a, node const &b) { return {a.data + b.data}; }",
      "  ll data;",
      "  void apply(ll tl, ll tr, tag const &t) { data += (tr - tl + 1) * t.inc; }",
      "  template <typename T>",
      "  void init(ll tl, ll tr, T &ddata) {",
      "    this->data = ddata;",
      "  }",
      "};"
    ]
  },
  "tree lifting": {
    "prefix": "tree_lifting",
    "body": [
      "struct tree_lifting {",
      "  vector<int> dep, jmp, fa;",
      "  int n;",
      "  void add_leaf(int cur, int par) {",
      "    fa[cur] = par;",
      "    dep[cur] = 1 + dep[par];",
      "    if (dep[par] - dep[jmp[par]] ==",
      "        dep[jmp[par]] - dep[jmp[jmp[par]]]) {",
      "      jmp[cur] = jmp[jmp[par]];",
      "    } else {",
      "      jmp[cur] = par;",
      "    }",
      "  }",
      "  void dfs(int cur, int par, vector<vector<int>> &adj) {",
      "    add_leaf(cur, par);",
      "    for (int it : adj[cur]) {",
      "      if (it == par) continue;",
      "      dfs(it, cur, adj);",
      "    }",
      "  }",
      "  void init(int nn) {",
      "    dep.resize(nn), jmp.resize(nn), fa.resize(nn);",
      "    this->n = nn;",
      "  }",
      "  int lift(int cur, int k) {",
      "    int new_depth = max(dep[cur] - k, 0);",
      "    while (dep[cur] > new_depth) {",
      "      if (dep[jmp[cur]] >= new_depth) cur = jmp[cur];",
      "      else cur = fa[cur];",
      "    } return cur;",
      "  }",
      "  int lca(int u, int v) {",
      "    if (dep[u] > dep[v]) swap(u, v);",
      "    v = lift(v, dep[v] - dep[u]);",
      "    while (u != v) {",
      "      if (jmp[v] != jmp[u]) {",
      "        u = jmp[u];",
      "        v = jmp[v];",
      "      } else {",
      "        u = fa[u];",
      "        v = fa[v];",
      "      }",
      "    } return u;",
      "  }",
      "  int dist(int u, int v) { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }",
      "};"
    ]
  },
  "fenwick": {
    "prefix": "fenwick-tree",
    "body": [
      "template <class T>",
      "class BIT {",
      " private:",
      "  int size;",
      "  vector<T> bit;",
      "  vector<T> arr;",
      " public:",
      "  BIT(int size) : size(size), bit(size + 1), arr(size) {}",
      "  void set(int ind, int val) { add(ind, val - arr[ind]); }",
      "  void add(int ind, int val) {",
      "    arr[ind] += val;",
      "    ind++;",
      "    for (; ind <= size; ind += ind & -ind) {",
      "      bit[ind] += val;",
      "    }",
      "  }",
      "  T pref_sum(int ind) {",
      "    ind++;",
      "    T total = 0;",
      "    for (; ind > 0; ind -= ind & -ind) {",
      "      total += bit[ind];",
      "    }",
      "    return total;",
      "  }",
      "};"
    ]
  },
  "hld": {
    "prefix": "hld",
    "body": [
      "template <int SZ, bool VALS_IN_EDGES>",
      "struct HLD {",
      "  int N;",
      "  vector<int> adj[SZ];",
      "  int par[SZ], root[SZ], depth[SZ], sz[SZ], ti;",
      "  int pos[SZ];",
      "  vector<int> rpos;  // not used but could be useful;",
      "  void ae(int x, int y) {",
      "    adj[x].push_back(y);",
      "    adj[y].push_back(x);",
      "  }",
      "  void dfsSz(int x) {",
      "    sz[x] = 1;",
      "    for (auto &y : adj[x]) {",
      "      par[y] = x;",
      "      depth[y] = depth[x] + 1;",
      "      adj[y].erase(find(adj[y].begin(), adj[y].end(), x));",
      "      dfsSz(y);",
      "      sz[x] += sz[y];",
      "      if (sz[y] > sz[adj[x][0]]) swap(y, adj[x][0]);",
      "    }",
      "  }",
      "  void dfsHld(int x) {",
      "    pos[x] = ti++;",
      "    rpos.push_back(x);",
      "    for (auto &y : adj[x]) {",
      "      root[y] = (y == adj[x][0] ? root[x] : y);",
      "      dfsHld(y);",
      "    }",
      "  }",
      "  void init(int _N, int R = 0) {",
      "    N = _N;",
      "    par[R] = depth[R] = ti = 0;",
      "    dfsSz(R);",
      "    root[R] = R;",
      "    dfsHld(R);",
      "  }",
      "  int lca(int x, int y) {",
      "    for (; root[x] != root[y]; y = par[root[y]]) {",
      "      if (depth[root[x]] > depth[root[y]]) swap(x, y);",
      "    }",
      "    return depth[x] < depth[y] ? x : y;",
      "  }",
      "  int dist(int x, int y) { return depth[x] + depth[y] - 2 * depth[lca(x, y)]; }",
      "  template <class BinaryOp>",
      "  void processPath(int x, int y, BinaryOp op) {",
      "    for (; root[x] != root[y]; y = par[root[y]]) {",
      "      if (depth[root[x]] > depth[root[y]]) swap(x, y);",
      "      op(pos[root[y]], pos[y]);",
      "    }",
      "    if (depth[x] > depth[y]) swap(x, y);",
      "    op(pos[x] + VALS_IN_EDGES, pos[y]);",
      "  }",
      "  void modifyPath(int x, int y, int v) {",
      "    processPath(x, y, [this, &v](int l, int r) {",
      "      // modify range [l, r]",
      "    });",
      "  }",
      "  ll queryPath(int x, int y) {",
      "    ll res = 0;",
      "    processPath(x, y, [this, &res](int l, int r) {",
      "      // query range [l, r]",
      "    });",
      "    return res;",
      "  }",
      "  void modifySubtree(int x, int v) {",
      "    // update range",
      "    // [ pos[x] + VALS_IN_EDGES, pos[x] + sz[x] - 1 ]",
      "  }",
      "};"
    ]
  }
}
